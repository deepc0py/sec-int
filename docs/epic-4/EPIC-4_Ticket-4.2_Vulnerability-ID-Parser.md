
# EPIC-4 · Ticket 4.2 — Develop Parser for OWASP and MITRE ATT&CK Identifiers

**Epic:** Scan Result Processing and Orchestration  
**Type:** Feature  
**Priority:** High  
**Estimate:** 1 day  
**Owner:** Senior SWE  
**Dependencies:** Ticket 4.1 (normalized input), EPIC-3 Ticket 3.1 (models)  
**References:** Master spec

## Summary
Implement a robust parser that scans normalized text and extracts all **OWASP Top 10 2021** and **MITRE ATT&CK Enterprise** identifiers, de-duplicates them, and returns `VulnerabilityFinding` objects.

## Scope
- Module: `src/app/parser.py`
- Public API: `def extract_vulnerability_ids(text: str) -> list[VulnerabilityFinding]`
- Identifier patterns:
  - MITRE: `T\d{4}` and `T\d{4}\.\d{3}`
  - OWASP: `A\d{1,2}:\d{4}` and `API\d{1,2}:\d{4}` (reserve for API list; MVP focuses on Axx:2021 but support both patterns)
- De-duplication preserving first-seen order.
- Tolerate punctuation around IDs; enforce word boundaries.

## Tasks
- [ ] Implement regex finds with compiled patterns:
  - [ ] `r"\b(T\d{4}(?:\.\d{3})?)\b"` for MITRE
  - [ ] `r"\b(A(?:PI)?\d{1,2}:\d{4})\b"` for OWASP/API
- [ ] Build `VulnerabilityFinding` for each unique match with `source` inferred from prefix (`T` => `mitre`, otherwise `owasp`).
- [ ] Provide `extract_vulnerability_ids(text)` returning a stable ordered list.
- [ ] Unit tests covering:
  - [ ] Mixed text with multiple IDs, duplicates, punctuation.
  - [ ] Sub-techniques like `T1059.006`.
  - [ ] OWASP `A01:2021` and API variants (if present).
  - [ ] No false positives in common cases (e.g., `T1000x` should not match).
- [ ] Add small fuzz tests for boundary conditions.
- [ ] Document usage examples in `docs/parser.md`.

## Acceptance Criteria
- [ ] Given the example text in tests, parser returns the correct unique sequence of IDs.
- [ ] Each result is a `VulnerabilityFinding(id=..., source=...)`.
- [ ] Regexes use word boundaries and do not capture partial strings.
- [ ] Test coverage >= 90% for this module.

## Technical Notes
Implementation sketch:
```python
# src/app/parser.py
import re
from app.models import VulnerabilityFinding

MITRE_RE = re.compile(r"\b(T\d{4}(?:\.\d{3})?)\b")
OWASP_RE = re.compile(r"\b(A(?:PI)?\d{1,2}:\d{4})\b")

def extract_vulnerability_ids(text: str) -> list[VulnerabilityFinding]:
    seen = set()
    out: list[VulnerabilityFinding] = []
    for pat, source in [(MITRE_RE, "mitre"), (OWASP_RE, "owasp")]:
        for m in pat.findall(text or ""):
            if m not in seen:
                seen.add(m)
                out.append(VulnerabilityFinding(id=m, source=source))
    # Preserve original order across patterns by scanning text twice with index mapping (optional improvement).
    return out
```
Notes:
- If strict original order is desired, scan with a single regex that alternates both patterns and use `finditer` to capture positions, then stable-sort by start offset.
